import numpy as np


class EllipticalSliceSampler(object):
    """Elliptical Slice Sampler Class"""
    def __init__(self, prior_mean, prior_cov, log_likelihood, n_burn, n_sample):
        """Initialize parameters of the elliptical slice sampler object."""
        self.n_burn = n_burn
        self.n_sample = n_sample
        self.prior_mean, self.prior_cov = prior_mean, prior_cov
        self.log_likelihood = log_likelihood

    def __sample(self, f):
        """This is actually the core of the elliptical slice sampling algorithm.
        """
        # Choose ellipse.
        k = f.shape[0]
        nu = np.random.multivariate_normal(np.zeros((k, )), self.prior_cov)
        # Set a log-likelihood threshold for acceptance.
        log_y = self.log_likelihood(f) + np.log(np.random.uniform())
        # Define the search bracket.
        theta = np.random.uniform(low=0., high=2.*np.pi)
        theta_min, theta_max = theta - 2.*np.pi, theta

        # Iterate until a point can be accepted according to the likelihood
        # criterion.
        while True:
            # Compute a candidate.
            fp = (
                (f - self.prior_mean) * np.cos(theta) + nu * np.sin(theta) +
                self.prior_mean
            )
            # Check the acceptance condition. If the candidate is not accepted,
            # then we shrink the search bracket exponentially quickly.
            if self.log_likelihood(fp) > log_y:
                return fp
            else:
                if theta < 0.:
                    theta_min = theta
                elif theta > 0.:
                    theta_max = theta
                else:
                    raise ValueError("Search bracket shrunk to zero.")

                theta = np.random.uniform(low=theta_min, high=theta_max)

    def sample(self, f=None):
        """Sample from the posterior distribution defined as a normal likelihood
        multiplied into an arbitrary likelihood.
        """
        # Initialize a matrix to store the samples generated by the elliptical
        # slice sampler.
        k = self.prior_mean.shape[0]
        samples = np.zeros((self.n_sample, k))
        # Handle the case where no initial state was provided.
        samples[0] = f if f else self.prior_mean

        # Iterate for a number of times equal to the sum of the burn iterations
        # and the actual sampling iterations.
        for i in range(1, self.n_burn + self.n_sample):
            s = self.__sample(samples[i-1])
            samples[i] = s

        return samples[-self.n_sample:]
